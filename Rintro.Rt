
R version 3.3.3 (2017-03-06) -- "Another Canoe"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R ist freie Software und kommt OHNE JEGLICHE GARANTIE.
Sie sind eingeladen, es unter bestimmten Bedingungen weiter zu verbreiten.
Tippen Sie 'license()' or 'licence()' für Details dazu.

R ist ein Gemeinschaftsprojekt mit vielen Beitragenden.
Tippen Sie 'contributors()' für mehr Information und 'citation()',
um zu erfahren, wie R oder R packages in Publikationen zitiert werden können.

Tippen Sie 'demo()' für einige Demos, 'help()' für on-line Hilfe, oder
'help.start()' für eine HTML Browserschnittstelle zur Hilfe.
Tippen Sie 'q()', um R zu verlassen.

> options(STERM='iESS', str.dendrogram.last="'", editor='emacsclient', show.error.locations=TRUE)
> ##### R-Script for catching up with R
> ##### Gerhard Nachtmann
> ##### 20170612-13
> ### logical vector
> lv <- c(TRUE, TRUE, FALSE, rep(TRUE, 7))
> # lv[7:9] <- c(FALSE, FALSE)
> typeof(lv)
[1] "logical"
> sum(lv)
[1] 9
> sum(lv)/length(lv)
[1] 0.9
> ### integer
> iv <- c(2L, 5L, as.integer(seq(2, 16, by = 2)))
> typeof(iv)
[1] "integer"
> 1:7
[1] 1 2 3 4 5 6 7
> is.integer(iv)
[1] TRUE
> ?seq()
seq                    package:base                    R Documentation

Sequence Generation

Description:

     Generate regular sequences.  ‘seq’ is a standard generic with a
     default method.  ‘seq.int’ is a primitive which can be much faster
     but has a few restrictions.  ‘seq_along’ and ‘seq_len’ are very
     fast primitives for two common cases.

Usage:

     seq(...)
     
     ## Default S3 method:
     seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
         length.out = NULL, along.with = NULL, ...)
     
     seq.int(from, to, by, length.out, along.with, ...)
     
     seq_along(along.with)
     seq_len(length.out)
     
Arguments:

     ...: arguments passed to or from methods.

from, to: the starting and (maximal) end values of the sequence.  Of
          length ‘1’ unless just ‘from’ is supplied as an unnamed
          argument.

      by: number: increment of the sequence.

length.out: desired length of the sequence.  A non-negative number,
          which for ‘seq’ and ‘seq.int’ will be rounded up if
          fractional.

along.with: take the length from the length of this argument.

Details:

     Numerical inputs should all be finite (that is, not infinite,
     ‘NaN’ or ‘NA’).

     The interpretation of the unnamed arguments of ‘seq’ and ‘seq.int’
     is _not_ standard, and it is recommended always to name the
     arguments when programming.

     ‘seq’ is generic, and only the default method is described here.
     Note that it dispatches on the class of the *first* argument
     irrespective of argument names.  This can have unintended
     consequences if it is called with just one argument intending this
     to be taken as ‘along.with’: it is much better to use ‘seg_along’
     in that case.

     ‘seq.int’ is an internal generic which dispatches on methods for
     ‘"seq"’ based on the class of the first supplied argument (before
     argument matching).

     Typical usages are
     
     seq(from, to)
     seq(from, to, by= )
     seq(from, to, length.out= )
     seq(along.with= )
     seq(from)
     seq(length.out= )

     The first form generates the sequence ‘from, from+/-1, ..., to’
     (identical to ‘from:to’).

     The second form generates ‘from, from+by’, ..., up to the sequence
     value less than or equal to ‘to’.  Specifying ‘to - from’ and ‘by’
     of opposite signs is an error.  Note that the computed final value
     can go just beyond ‘to’ to allow for rounding error, but is
     truncated to ‘to’.  (‘Just beyond’ is by up to 1e-10 times
     ‘abs(from - to)’.)

     The third generates a sequence of ‘length.out’ equally spaced
     values from ‘from’ to ‘to’.  (‘length.out’ is usually abbreviated
     to ‘length’ or ‘len’, and ‘seq_len’ is much faster.)

     The fourth form generates the integer sequence ‘1, 2, ...,
     length(along.with)’.  (‘along.with’ is usually abbreviated to
     ‘along’, and ‘seq_along’ is much faster.)

     The fifth form generates the sequence ‘1, 2, ..., length(from)’
     (as if argument ‘along.with’ had been specified), _unless_ the
     argument is numeric of length 1 when it is interpreted as ‘1:from’
     (even for ‘seq(0)’ for compatibility with S).  Using either
     ‘seq_along’ or ‘seq_len’ is much preferred (unless strict S
     compatibility is essential).

     The final form generates the integer sequence ‘1, 2, ...,
     length.out’ unless ‘length.out = 0’, when it generates
     ‘integer(0)’.

     Very small sequences (with ‘from - to’ of the order of 10^{-14}
     times the larger of the ends) will return ‘from’.

     For ‘seq’ (only), up to two of ‘from’, ‘to’ and ‘by’ can be
     supplied as complex values provided ‘length.out’ or ‘along.with’
     is specified.  More generally, the default method of ‘seq’ will
     handle classed objects with methods for the ‘Math’, ‘Ops’ and
     ‘Summary’ group generics.

     ‘seq.int’, ‘seq_along’ and ‘seq_len’ are primitive.

Value:

     ‘seq.int’ and the default method of ‘seq’ for numeric arguments
     return a vector of type ‘"integer"’ or ‘"double"’: programmers
     should not rely on which.

     ‘seq_along’ and ‘seq_len’ return an integer vector, unless it is a
     _long vector_ when it will be double.

References:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

See Also:

     The methods ‘seq.Date’ and ‘seq.POSIXt’.

     ‘:’, ‘rep’, ‘sequence’, ‘row’, ‘col’.

Examples:

     seq(0, 1, length.out = 11)
     seq(stats::rnorm(20)) # effectively 'along'
     seq(1, 9, by = 2)     # matches 'end'
     seq(1, 9, by = pi)    # stays below 'end'
     seq(1, 6, by = 3)
     seq(1.575, 5.125, by = 0.05)
     seq(17) # same as 1:17, or even better seq_len(17)
     

> ### double (numeric)
> dv <- numeric(10)
> set.seed(1)
> dv <- c(seq(2, 16, by = 2.5), rnorm(4))
> rnorm(10, 5, 0.2)
 [1] 5.065902 4.835906 5.097486 5.147665 5.115156 4.938922 5.302356 5.077969
 [9] 4.875752 4.557060
> rnorm(10, 5, 0.2)
 [1] 5.224986 4.991013 4.996762 5.188767 5.164244 5.118780 5.183795 5.156427
 [9] 5.014913 4.602130
> set.seed(10)
> rnorm(10, 5, 0.2)
 [1] 5.003749 4.963149 4.725734 4.880166 5.058909 5.077959 4.758385 4.927265
 [9] 4.674665 4.948704
> rnorm(10, 5, 0.2)
 [1] 5.220356 5.151156 4.952353 5.197489 5.148278 5.017869 4.809011 4.960970
 [9] 5.185104 5.096596
> dv
 [1]  2.0000000  4.5000000  7.0000000  9.5000000 12.0000000 14.5000000
 [7] -0.6264538  0.1836433 -0.8356286  1.5952808
> ### character vector
> cv <- c("sdf", rep("SLU", 3))
> cv
[1] "sdf" "SLU" "SLU" "SLU"
> letters[7:9]
[1] "g" "h" "i"
> cv <- letters[iv]
> sample(LETTERS, 30, replace = TRUE)
 [1] "H" "F" "A" "S" "G" "E" "A" "M" "C" "U" "J" "Y" "G" "M" "E" "P" "L" "M" "K"
[20] "N" "A" "C" "M" "K" "V" "T" "O" "L" "C" "F"
> typeof(cv)
[1] "character"
> ### factor (special case of integer)
> quality <- factor(c("A", "B", "A", "C", "C", "A", "C", "C"),
+                   levels = c("C", "B", "A"),
+                   ordered = TRUE)
> ### combine it
> t1 <- c(cv, iv)
> is.character(c(cv, iv))
[1] TRUE
> t1[c(2, 15)]
[1] "e" "6"
> t1[c(2, 15)] <- NA
> iv1 <- (NA_real_)
> mode(NA)
[1] "logical"
> mode(NA_character_)
[1] "character"
> ### list
> vector(mode = "list", length = 3)
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

> l1 <- list(cv, iv, dv)
> length(l1)
[1] 3
> l1[[2]][2]
[1] 5
> class(l1)
[1] "list"
> l1[2]
[[1]]
 [1]  2  5  2  4  6  8 10 12 14 16

> class(l1[2])
[1] "list"
> length(l1[2])
[1] 1
> l1[[2]]
 [1]  2  5  2  4  6  8 10 12 14 16
> class(l1[[2]])
[1] "integer"
> length(l1[[2]])
[1] 10
> unlist(l1)
 [1] "b"                  "e"                  "b"                 
 [4] "d"                  "f"                  "h"                 
 [7] "j"                  "l"                  "n"                 
[10] "p"                  "2"                  "5"                 
[13] "2"                  "4"                  "6"                 
[16] "8"                  "10"                 "12"                
[19] "14"                 "16"                 "2"                 
[22] "4.5"                "7"                  "9.5"               
[25] "12"                 "14.5"               "-0.626453810742332"
[28] "0.183643324222082"  "-0.835628612410047" "1.59528080213779"  
> l2 <- list(x = l1, y = runif(10))
> length(l2[["x"]])
[1] 3
> l2[["x"]]
[[1]]
 [1] "b" "e" "b" "d" "f" "h" "j" "l" "n" "p"

[[2]]
 [1]  2  5  2  4  6  8 10 12 14 16

[[3]]
 [1]  2.0000000  4.5000000  7.0000000  9.5000000 12.0000000 14.5000000
 [7] -0.6264538  0.1836433 -0.8356286  1.5952808

> l2[[1]]
[[1]]
 [1] "b" "e" "b" "d" "f" "h" "j" "l" "n" "p"

[[2]]
 [1]  2  5  2  4  6  8 10 12 14 16

[[3]]
 [1]  2.0000000  4.5000000  7.0000000  9.5000000 12.0000000 14.5000000
 [7] -0.6264538  0.1836433 -0.8356286  1.5952808

> names(l2)
[1] "x" "y"
> l3 <- list(x = 1:15, y = 10:1)
> l3
$x
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15

$y
 [1] 10  9  8  7  6  5  4  3  2  1

> list(x = seq(1, 15), y = rev(1:10))
$x
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15

$y
 [1] 10  9  8  7  6  5  4  3  2  1

> rev(letters)
 [1] "z" "y" "x" "w" "v" "u" "t" "s" "r" "q" "p" "o" "n" "m" "l" "k" "j" "i" "h"
[20] "g" "f" "e" "d" "c" "b" "a"
> ### data.frame
> length(iv)
[1] 10
> length(cv)
[1] 10
> stopifnot(length(iv) == length(cv))
> # stopifnot(length(iv) == 15)
> df1 <- data.frame(x = iv, y = cv,
+                   stringsAsFactors = FALSE)
> df1
    x y
1   2 b
2   5 e
3   2 b
4   4 d
5   6 f
6   8 h
7  10 j
8  12 l
9  14 n
10 16 p
> df1f <- data.frame(x = iv, y = cv)
> str(df1f)
'data.frame':	10 obs. of  2 variables:
 $ x: int  2 5 2 4 6 8 10 12 14 16
 $ y: Factor w/ 9 levels "b","d","e","f",..: 1 3 1 2 4 5 6 7 8 9
> cv[2] <- "x"
> cv
 [1] "b" "x" "b" "d" "f" "h" "j" "l" "n" "p"
> df1
    x y
1   2 b
2   5 e
3   2 b
4   4 d
5   6 f
6   8 h
7  10 j
8  12 l
9  14 n
10 16 p
> df1[2, 2]
[1] "e"
> str(df1)
'data.frame':	10 obs. of  2 variables:
 $ x: int  2 5 2 4 6 8 10 12 14 16
 $ y: chr  "b" "e" "b" "d" ...
> head(df1)
  x y
1 2 b
2 5 e
3 2 b
4 4 d
5 6 f
6 8 h
> tail(df1, 3)
    x y
8  12 l
9  14 n
10 16 p
> df2 <- data.frame(iv, cv, dv, lv)
> df2
   iv cv         dv    lv
1   2  b  2.0000000  TRUE
2   5  x  4.5000000  TRUE
3   2  b  7.0000000 FALSE
4   4  d  9.5000000  TRUE
5   6  f 12.0000000  TRUE
6   8  h 14.5000000  TRUE
7  10  j -0.6264538  TRUE
8  12  l  0.1836433  TRUE
9  14  n -0.8356286  TRUE
10 16  p  1.5952808  TRUE
> str(df2)
'data.frame':	10 obs. of  4 variables:
 $ iv: int  2 5 2 4 6 8 10 12 14 16
 $ cv: Factor w/ 9 levels "b","d","f","h",..: 1 9 1 2 3 4 5 6 7 8
 $ dv: num  2 4.5 7 9.5 12 ...
 $ lv: logi  TRUE TRUE FALSE TRUE TRUE TRUE ...
> df2[2:3, 2]
[1] x b
Levels: b d f h j l n p x
> df2[5, 2:4]
  cv dv   lv
5  f 12 TRUE
> df2[5, ]
  iv cv dv   lv
5  6  f 12 TRUE
> df2[, 2]
 [1] b x b d f h j l n p
Levels: b d f h j l n p x
> df2[-5, ]
   iv cv         dv    lv
1   2  b  2.0000000  TRUE
2   5  x  4.5000000  TRUE
3   2  b  7.0000000 FALSE
4   4  d  9.5000000  TRUE
6   8  h 14.5000000  TRUE
7  10  j -0.6264538  TRUE
8  12  l  0.1836433  TRUE
9  14  n -0.8356286  TRUE
10 16  p  1.5952808  TRUE
> df2[6, 2]
[1] h
Levels: b d f h j l n p x
> names(df2)
[1] "iv" "cv" "dv" "lv"
> is.list(df2)
[1] TRUE
> class(df2)
[1] "data.frame"
> df2[[2]]
 [1] b x b d f h j l n p
Levels: b d f h j l n p x
> df2[[2]] == df2[, 2]
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> all(df2[[2]] == df2[, 2])
[1] TRUE
> sum(df2[[2]] != df2[, 2])
[1] 0
> all(df2[[2]] == factor(cv))
[1] TRUE
> all(df2[[2]] == cv)
[1] TRUE
> all.equal(df2[[2]], df2[, 2])
[1] TRUE
> str(df2)
'data.frame':	10 obs. of  4 variables:
 $ iv: int  2 5 2 4 6 8 10 12 14 16
 $ cv: Factor w/ 9 levels "b","d","f","h",..: 1 9 1 2 3 4 5 6 7 8
 $ dv: num  2 4.5 7 9.5 12 ...
 $ lv: logi  TRUE TRUE FALSE TRUE TRUE TRUE ...
> df2$cv
 [1] b x b d f h j l n p
Levels: b d f h j l n p x
> ### special values
> t2 <- dv
> t2[5] <- NA
> t2[9] <- 0
> t2
 [1]  2.0000000  4.5000000  7.0000000  9.5000000         NA 14.5000000
 [7] -0.6264538  0.1836433  0.0000000  1.5952808
> summary(t2)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
-0.6265  0.1836  2.0000  4.2950  7.0000 14.5000       1 
> sum(t2)
[1] NA
> sum(dv)
[1] 49.81684
> sum(t2, na.rm = TRUE)
[1] 38.65247
> sum(t2[-5])
[1] 38.65247
> 12 / t2
 [1]   6.0000000   2.6666667   1.7142857   1.2631579          NA   0.8275862
 [7] -19.1554426  65.3440578         Inf   7.5221867
> 0 / 0
[1] NaN
> t3 <- 12 / t2
> mean(t3, na.rm = TRUE)
[1] Inf
> median(t3, na.rm = TRUE)
[1] 2.666667
> t4 <- NULL
> is.null(NULL)
[1] TRUE
> length(NULL)
[1] 0
> length(NA)
[1] 1
> c(t4, iv)
 [1]  2  5  2  4  6  8 10 12 14 16
> length(c(t4, iv))
[1] 10
> c(NA, iv)
 [1] NA  2  5  2  4  6  8 10 12 14 16
> length(c(NA, iv))
[1] 11
> ### remove some objects
> rm(t1, t2, t4)
> ls()
 [1] "cv"      "df1"     "df1f"    "df2"     "dv"      "iv"      "iv1"    
 [8] "l1"      "l2"      "l3"      "lv"      "quality" "t3"     
> ### Data I/O
> getwd()
[1] "/home/tux/Dokumente/lehre/ISPS17"
> setwd("../")
> getwd()
[1] "/home/tux/Dokumente/lehre"
> setwd("ISPS17")
> file.path("lehre", "ISPS17")
[1] "lehre/ISPS17"
> ##### Afternoon
> getwd()
[1] "/home/tux/Dokumente/lehre/ISPS17"
> data(iris)
> head(iris)
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa
> str(iris)
'data.frame':	150 obs. of  5 variables:
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
> summary(iris)
  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   
 Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  
 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  
 Median :5.800   Median :3.000   Median :4.350   Median :1.300  
 Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  
 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  
 Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  
       Species  
 setosa    :50  
 versicolor:50  
 virginica :50  
                
                
                
> setwd("../../")
> getwd()
[1] "/home/tux/Dokumente"
> write.csv(iris, file = file.path("lehre", "ISPS17",
+                                  "iris.csv"),
+           row.names = FALSE)
> getwd()
[1] "/home/tux/Dokumente"
> ?write.csv
write.table               package:utils                R Documentation

Data Output

Description:

     ‘write.table’ prints its required argument ‘x’ (after converting
     it to a data frame if it is not one nor a matrix) to a file or
     connection.

Usage:

     write.table(x, file = "", append = FALSE, quote = TRUE, sep = " ",
                 eol = "\n", na = "NA", dec = ".", row.names = TRUE,
                 col.names = TRUE, qmethod = c("escape", "double"),
                 fileEncoding = "")
     
     write.csv(...)
     write.csv2(...)
     
Arguments:

       x: the object to be written, preferably a matrix or data frame.
          If not, it is attempted to coerce ‘x’ to a data frame.

    file: either a character string naming a file or a connection open
          for writing.  ‘""’ indicates output to the console.

  append: logical. Only relevant if ‘file’ is a character string.  If
          ‘TRUE’, the output is appended to the file.  If ‘FALSE’, any
          existing file of the name is destroyed.

   quote: a logical value (‘TRUE’ or ‘FALSE’) or a numeric vector.  If
          ‘TRUE’, any character or factor columns will be surrounded by
          double quotes.  If a numeric vector, its elements are taken
          as the indices of columns to quote.  In both cases, row and
          column names are quoted if they are written.  If ‘FALSE’,
          nothing is quoted.

     sep: the field separator string.  Values within each row of ‘x’
          are separated by this string.

     eol: the character(s) to print at the end of each line (row).  For
          example, ‘eol = "\r\n"’ will produce Windows' line endings on
          a Unix-alike OS, and ‘eol = "\r"’ will produce files as
          expected by Excel:mac 2004.

      na: the string to use for missing values in the data.

     dec: the string to use for decimal points in numeric or complex
          columns: must be a single character.

row.names: either a logical value indicating whether the row names of
          ‘x’ are to be written along with ‘x’, or a character vector
          of row names to be written.

col.names: either a logical value indicating whether the column names
          of ‘x’ are to be written along with ‘x’, or a character
          vector of column names to be written.  See the section on
          ‘CSV files’ for the meaning of ‘col.names = NA’.

 qmethod: a character string specifying how to deal with embedded
          double quote characters when quoting strings.  Must be one of
          ‘"escape"’ (default for ‘write.table’), in which case the
          quote character is escaped in C style by a backslash, or
          ‘"double"’ (default for ‘write.csv’ and ‘write.csv2’), in
          which case it is doubled.  You can specify just the initial
          letter.

fileEncoding: character string: if non-empty declares the encoding to
          be used on a file (not a connection) so the character data
          can be re-encoded as they are written.  See ‘file’.

     ...: arguments to ‘write.table’: ‘append’, ‘col.names’, ‘sep’,
          ‘dec’ and ‘qmethod’ cannot be altered.

Details:

     If the table has no columns the rownames will be written only if
     ‘row.names = TRUE’, and _vice versa_.

     Real and complex numbers are written to the maximal possible
     precision.

     If a data frame has matrix-like columns these will be converted to
     multiple columns in the result (_via_ ‘as.matrix’) and so a
     character ‘col.names’ or a numeric ‘quote’ should refer to the
     columns in the result, not the input.  Such matrix-like columns
     are unquoted by default.

     Any columns in a data frame which are lists or have a class (e.g.,
     dates) will be converted by the appropriate ‘as.character’ method:
     such columns are unquoted by default.  On the other hand, any
     class information for a matrix is discarded and non-atomic (e.g.,
     list) matrices are coerced to character.

     Only columns which have been converted to character will be quoted
     if specified by ‘quote’.

     The ‘dec’ argument only applies to columns that are not subject to
     conversion to character because they have a class or are part of a
     matrix-like column (or matrix), in particular to columns protected
     by ‘I()’.  Use ‘options("OutDec")’ to control such conversions.

     In almost all cases the conversion of numeric quantities is
     governed by the option ‘"scipen"’ (see ‘options’), but with the
     internal equivalent of ‘digits = 15’.  For finer control, use
     ‘format’ to make a character matrix/data frame, and call
     ‘write.table’ on that.

     These functions check for a user interrupt every 1000 lines of
     output.

     If ‘file’ is a non-open connection, an attempt is made to open it
     and then close it after use.

     To write a Unix-style file on Windows, use a binary connection
     e.g. ‘file = file("filename", "wb")’.

CSV files:

     By default there is no column name for a column of row names.  If
     ‘col.names = NA’ and ‘row.names = TRUE’ a blank column name is
     added, which is the convention used for CSV files to be read by
     spreadsheets.  Note that such CSV files can be read in R by
     
       read.csv(file = "<filename>", row.names = 1)

     ‘write.csv’ and ‘write.csv2’ provide convenience wrappers for
     writing CSV files.  They set ‘sep’ and ‘dec’ (see below), ‘qmethod
     = "double"’, and ‘col.names’ to ‘NA’ if ‘row.names = TRUE’ (the
     default) and to ‘TRUE’ otherwise.

     ‘write.csv’ uses ‘"."’ for the decimal point and a comma for the
     separator.

     ‘write.csv2’ uses a comma for the decimal point and a semicolon
     for the separator, the Excel convention for CSV files in some
     Western European locales.

     These wrappers are deliberately inflexible: they are designed to
     ensure that the correct conventions are used to write a valid
     file.  Attempts to change ‘append’, ‘col.names’, ‘sep’, ‘dec’ or
     ‘qmethod’ are ignored, with a warning.

     CSV files do not record an encoding, and this causes problems if
     they are not ASCII for many other applications.  Windows Excel
     2007/10 will open files (e.g., by the file association mechanism)
     correctly if they are ASCII or UTF-16 (use ‘fileEncoding =
     "UTF-16LE"’) or perhaps in the current Windows codepage (e.g.,
     ‘"CP1252"’), but the ‘Text Import Wizard’ (from the ‘Data’ tab)
     allows far more choice of encodings.  Excel:mac 2004/8 can
     _import_ only ‘Macintosh’ (which seems to mean Mac Roman),
     ‘Windows’ (perhaps Latin-1) and ‘PC-8’ files.  OpenOffice 3.x asks
     for the character set when opening the file.

     There is an IETF RFC4180 (<URL:
     https://tools.ietf.org/html/rfc4180>) for CSV files, which
     mandates comma as the separator and CRLF line endings.
     ‘write.csv’ writes compliant files on Windows: use ‘eol = "\r\n"’
     on other platforms.

Note:

     ‘write.table’ can be slow for data frames with large numbers
     (hundreds or more) of columns: this is inevitable as each column
     could be of a different class and so must be handled separately.
     If they are all of the same class, consider using a matrix
     instead.

See Also:

     The ‘R Data Import/Export’ manual.

     ‘read.table’, ‘write’.

     ‘write.matrix’ in package ‘MASS’.

Examples:

     ## Not run:
     
     ## To write a CSV file for input to Excel one might use
     x <- data.frame(a = I("a \" quote"), b = pi)
     write.table(x, file = "foo.csv", sep = ",", col.names = NA,
                 qmethod = "double")
     ## and to read this file back into R one needs
     read.table("foo.csv", header = TRUE, sep = ",", row.names = 1)
     ## NB: you do need to specify a separator if qmethod = "double".
     
     ### Alternatively
     write.csv(x, file = "foo.csv")
     read.csv("foo.csv", row.names = 1)
     ## or without row names
     write.csv(x, file = "foo.csv", row.names = FALSE)
     read.csv("foo.csv")
     
     ## To write a file in Mac Roman for simple use in Mac Excel 2004/8
     write.csv(x, file = "foo.csv", fileEncoding = "macroman")
     ## or for Windows Excel 2007/10
     write.csv(x, file = "foo.csv", fileEncoding = "UTF-16LE")
     ## End(Not run)
     

> setwd(file.path("lehre", "ISPS17"))
> getwd()
[1] "/home/tux/Dokumente/lehre/ISPS17"
> iriscsv <- read.csv("iris.csv")
> ls()
 [1] "cv"      "df1"     "df1f"    "df2"     "dv"      "iris"    "iriscsv"
 [8] "iv"      "iv1"     "l1"      "l2"      "l3"      "lv"      "quality"
[15] "t3"     
> str(iriscsv)
'data.frame':	150 obs. of  5 variables:
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
> all.equal(iris, iriscsv)
[1] TRUE
> quality
[1] A B A C C A C C
Levels: C < B < A
> quality < "B"
[1] FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE
> sum(quality < "B")
[1] 4
> quality[quality < "B"]
[1] C C C C
Levels: C < B < A
> iv[1:8][quality < "B"]
[1]  4  6 10 12
> head(df2)
  iv cv   dv    lv
1  2  b  2.0  TRUE
2  5  x  4.5  TRUE
3  2  b  7.0 FALSE
4  4  d  9.5  TRUE
5  6  f 12.0  TRUE
6  8  h 14.5  TRUE
> subset(df2, cv == "b")
  iv cv dv    lv
1  2  b  2  TRUE
3  2  b  7 FALSE
> subset(df2, cv %in% c("b", "h"))
  iv cv   dv    lv
1  2  b  2.0  TRUE
3  2  b  7.0 FALSE
6  8  h 14.5  TRUE
> subset(df2, iv > 8)
   iv cv         dv   lv
7  10  j -0.6264538 TRUE
8  12  l  0.1836433 TRUE
9  14  n -0.8356286 TRUE
10 16  p  1.5952808 TRUE
> subset(df2, lv)
   iv cv         dv   lv
1   2  b  2.0000000 TRUE
2   5  x  4.5000000 TRUE
4   4  d  9.5000000 TRUE
5   6  f 12.0000000 TRUE
6   8  h 14.5000000 TRUE
7  10  j -0.6264538 TRUE
8  12  l  0.1836433 TRUE
9  14  n -0.8356286 TRUE
10 16  p  1.5952808 TRUE
> df2[!lv, ]
  iv cv dv    lv
3  2  b  7 FALSE
> rm(lv)
> df2[!df2$lv, ]
  iv cv dv    lv
3  2  b  7 FALSE
> seq(0, 20, by = 0.5)
 [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0
[16]  7.5  8.0  8.5  9.0  9.5 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5
[31] 15.0 15.5 16.0 16.5 17.0 17.5 18.0 18.5 19.0 19.5 20.0
> round(seq(0, 20, by = 0.5))
 [1]  0  0  1  2  2  2  3  4  4  4  5  6  6  6  7  8  8  8  9 10 10 10 11 12 12
[26] 12 13 14 14 14 15 16 16 16 17 18 18 18 19 20 20
> mean(seq(0, 20, by = 0.5))
[1] 10
> mean(round(seq(0, 20, by = 0.5)))
[1] 10
> round(rnorm(10), 2)
 [1]  1.09 -0.76 -0.83  0.83 -0.97 -0.03  0.23 -0.30 -0.68  0.66
> round(rnorm(10), digits = 2) # not needed
 [1] -0.40 -0.33  1.37  2.14  0.51  0.79 -0.90  0.53 -0.65  0.29
> round(digits = 2, x = rnorm(10))
 [1] -1.24 -0.46 -0.83  0.34  1.07  1.22  0.74 -0.48  0.56 -1.25
> ceiling(seq(0, 20, by = 0.5))
 [1]  0  1  1  2  2  3  3  4  4  5  5  6  6  7  7  8  8  9  9 10 10 11 11 12 12
[26] 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20 20
> ceiling(325.3)
[1] 326
> floor(seq(0, 20, by = 0.5))
 [1]  0  0  1  1  2  2  3  3  4  4  5  5  6  6  7  7  8  8  9  9 10 10 11 11 12
[26] 12 13 13 14 14 15 15 16 16 17 17 18 18 19 19 20
> round(325.4, -2)
[1] 300
> round(325.4, -1)
[1] 330
> paste(cv, 3)
 [1] "b 3" "x 3" "b 3" "d 3" "f 3" "h 3" "j 3" "l 3" "n 3" "p 3"
> paste(cv, 3, sep = "-")
 [1] "b-3" "x-3" "b-3" "d-3" "f-3" "h-3" "j-3" "l-3" "n-3" "p-3"
> paste(cv, 3, sep = "")
 [1] "b3" "x3" "b3" "d3" "f3" "h3" "j3" "l3" "n3" "p3"
> paste0(cv, 3)
 [1] "b3" "x3" "b3" "d3" "f3" "h3" "j3" "l3" "n3" "p3"
> paste0("run", 1:10)
 [1] "run1"  "run2"  "run3"  "run4"  "run5"  "run6"  "run7"  "run8"  "run9" 
[10] "run10"
> paste0("b", 0:5, collapse = "+")
[1] "b0+b1+b2+b3+b4+b5"
> seq_along(cv)
 [1]  1  2  3  4  5  6  7  8  9 10
> seq_along(NULL)
integer(0)
> 1:NULL
Fehler in 1:NULL : Argument der Länge 0
> seq_len(5)
[1] 1 2 3 4 5
> seq_len(length(cv)) # redundant
 [1]  1  2  3  4  5  6  7  8  9 10
> ### functions
> summary(df2) # generic
       iv              cv          dv              lv         
 Min.   : 2.00   b      :2   Min.   :-0.8356   Mode :logical  
 1st Qu.: 4.25   d      :1   1st Qu.: 0.5366   FALSE:1        
 Median : 7.00   f      :1   Median : 3.2500   TRUE :9        
 Mean   : 7.90   h      :1   Mean   : 4.9817   NA's :0        
 3rd Qu.:11.50   j      :1   3rd Qu.: 8.8750                  
 Max.   :16.00   l      :1   Max.   :14.5000                  
                 (Other):3                                    
> class(df2$cv)
[1] "factor"
> unclass(df2$cv)
 [1] 1 9 1 2 3 4 5 6 7 8
attr(,"levels")
[1] "b" "d" "f" "h" "j" "l" "n" "p" "x"
> ?factor
factor                  package:base                   R Documentation

Factors

Description:

     The function ‘factor’ is used to encode a vector as a factor (the
     terms ‘category’ and ‘enumerated type’ are also used for factors).
     If argument ‘ordered’ is ‘TRUE’, the factor levels are assumed to
     be ordered.  For compatibility with S there is also a function
     ‘ordered’.

     ‘is.factor’, ‘is.ordered’, ‘as.factor’ and ‘as.ordered’ are the
     membership and coercion functions for these classes.

Usage:

     factor(x = character(), levels, labels = levels,
            exclude = NA, ordered = is.ordered(x), nmax = NA)
     
     ordered(x, ...)
     
     is.factor(x)
     is.ordered(x)
     
     as.factor(x)
     as.ordered(x)
     
     addNA(x, ifany = FALSE)
     
Arguments:

       x: a vector of data, usually taking a small number of distinct
          values.

  levels: an optional vector of the values (as character strings) that
          ‘x’ might have taken.  The default is the unique set of
          values taken by ‘as.character(x)’, sorted into increasing
          order _of ‘x’_.  Note that this set can be specified as
          smaller than ‘sort(unique(x))’.

  labels: _either_ an optional character vector of labels for the
          levels (in the same order as ‘levels’ after removing those in
          ‘exclude’), _or_ a character string of length 1.

 exclude: a vector of values to be excluded when forming the set of
          levels.  This should be of the same type as ‘x’, and will be
          coerced if necessary.

 ordered: logical flag to determine if the levels should be regarded as
          ordered (in the order given).

    nmax: an upper bound on the number of levels; see ‘Details’.

     ...: (in ‘ordered(.)’): any of the above, apart from ‘ordered’
          itself.

   ifany: (only add an ‘NA’ level if it is used, i.e.  if
          ‘any(is.na(x))’.

Details:

     The type of the vector ‘x’ is not restricted; it only must have an
     ‘as.character’ method and be sortable (by ‘sort.list’).

     Ordered factors differ from factors only in their class, but
     methods and the model-fitting functions treat the two classes
     quite differently.

     The encoding of the vector happens as follows.  First all the
     values in ‘exclude’ are removed from ‘levels’. If ‘x[i]’ equals
     ‘levels[j]’, then the ‘i’-th element of the result is ‘j’.  If no
     match is found for ‘x[i]’ in ‘levels’ (which will happen for
     excluded values) then the ‘i’-th element of the result is set to
     ‘NA’.

     Normally the ‘levels’ used as an attribute of the result are the
     reduced set of levels after removing those in ‘exclude’, but this
     can be altered by supplying ‘labels’.  This should either be a set
     of new labels for the levels, or a character string, in which case
     the levels are that character string with a sequence number
     appended.

     ‘factor(x, exclude = NULL)’ applied to a factor is a no-operation
     unless there are unused levels: in that case, a factor with the
     reduced level set is returned.  If ‘exclude’ is used it should
     also be a factor with the same level set as ‘x’ or a set of codes
     for the levels to be excluded.

     The codes of a factor may contain ‘NA’.  For a numeric ‘x’, set
     ‘exclude = NULL’ to make ‘NA’ an extra level (prints as ‘<NA>’);
     by default, this is the last level.

     If ‘NA’ is a level, the way to set a code to be missing (as
     opposed to the code of the missing level) is to use ‘is.na’ on the
     left-hand-side of an assignment (as in ‘is.na(f)[i] <- TRUE’;
     indexing inside ‘is.na’ does not work).  Under those circumstances
     missing values are currently printed as ‘<NA>’, i.e., identical to
     entries of level ‘NA’.

     ‘is.factor’ is generic: you can write methods to handle specific
     classes of objects, see InternalMethods.

     Where ‘levels’ is not supplied, ‘unique’ is called.  Since factors
     typically have quite a small number of levels, for large vectors
     ‘x’ it is helpful to supply ‘nmax’ as an upper bound on the number
     of unique values.

Value:

     ‘factor’ returns an object of class ‘"factor"’ which has a set of
     integer codes the length of ‘x’ with a ‘"levels"’ attribute of
     mode ‘character’ and unique (‘!anyDuplicated(.)’) entries.  If
     argument ‘ordered’ is true (or ‘ordered()’ is used) the result has
     class ‘c("ordered", "factor")’.

     Applying ‘factor’ to an ordered or unordered factor returns a
     factor (of the same type) with just the levels which occur: see
     also ‘[.factor’ for a more transparent way to achieve this.

     ‘is.factor’ returns ‘TRUE’ or ‘FALSE’ depending on whether its
     argument is of type factor or not.  Correspondingly, ‘is.ordered’
     returns ‘TRUE’ when its argument is an ordered factor and ‘FALSE’
     otherwise.

     ‘as.factor’ coerces its argument to a factor.  It is an
     abbreviated form of ‘factor’.

     ‘as.ordered(x)’ returns ‘x’ if this is ordered, and ‘ordered(x)’
     otherwise.

     ‘addNA’ modifies a factor by turning ‘NA’ into an extra level (so
     that ‘NA’ values are counted in tables, for instance).

Warning:

     The interpretation of a factor depends on both the codes and the
     ‘"levels"’ attribute.  Be careful only to compare factors with the
     same set of levels (in the same order).  In particular,
     ‘as.numeric’ applied to a factor is meaningless, and may happen by
     implicit coercion.  To transform a factor ‘f’ to approximately its
     original numeric values, ‘as.numeric(levels(f))[f]’ is recommended
     and slightly more efficient than ‘as.numeric(as.character(f))’.

     The levels of a factor are by default sorted, but the sort order
     may well depend on the locale at the time of creation, and should
     not be assumed to be ASCII.

     There are some anomalies associated with factors that have ‘NA’ as
     a level.  It is suggested to use them sparingly, e.g., only for
     tabulation purposes.

Comparison operators and group generic methods:

     There are ‘"factor"’ and ‘"ordered"’ methods for the group generic
     ‘Ops’ which provide methods for the Comparison operators, and for
     the ‘min’, ‘max’, and ‘range’ generics in ‘Summary’ of
     ‘"ordered"’.  (The rest of the groups and the ‘Math’ group
     generate an error as they are not meaningful for factors.)

     Only ‘==’ and ‘!=’ can be used for factors: a factor can only be
     compared to another factor with an identical set of levels (not
     necessarily in the same ordering) or to a character vector.
     Ordered factors are compared in the same way, but the general
     dispatch mechanism precludes comparing ordered and unordered
     factors.

     All the comparison operators are available for ordered factors.
     Collation is done by the levels of the operands: if both operands
     are ordered factors they must have the same level set.

Note:

     In earlier versions of R, storing character data as a factor was
     more space efficient if there is even a small proportion of
     repeats.  However, identical character strings now share storage,
     so the difference is small in most cases.  (Integer values are
     stored in 4 bytes whereas each reference to a character string
     needs a pointer of 4 or 8 bytes.)

References:

     Chambers, J. M. and Hastie, T. J. (1992) _Statistical Models in
     S_.  Wadsworth & Brooks/Cole.

See Also:

     ‘[.factor’ for subsetting of factors.

     ‘gl’ for construction of balanced factors and ‘C’ for factors with
     specified contrasts.  ‘levels’ and ‘nlevels’ for accessing the
     levels, and ‘unclass’ to get integer codes.

Examples:

     (ff <- factor(substring("statistics", 1:10, 1:10), levels = letters))
     as.integer(ff)      # the internal codes
     (f. <- factor(ff))  # drops the levels that do not occur
     ff[, drop = TRUE]   # the same, more transparently
     
     factor(letters[1:20], labels = "letter")
     
     class(ordered(4:1)) # "ordered", inheriting from "factor"
     z <- factor(LETTERS[3:1], ordered = TRUE)
     ## and "relational" methods work:
     stopifnot(sort(z)[c(1,3)] == range(z), min(z) < max(z))
     
     
     ## suppose you want "NA" as a level, and to allow missing values.
     (x <- factor(c(1, 2, NA), exclude = NULL))
     is.na(x)[2] <- TRUE
     x  # [1] 1    <NA> <NA>
     is.na(x)
     # [1] FALSE  TRUE FALSE
     
     ## Using addNA()
     Month <- airquality$Month
     table(addNA(Month))
     table(addNA(Month, ifany = TRUE))
     

> 2^(0:10)
 [1]    1    2    4    8   16   32   64  128  256  512 1024
> (1:10)*4
 [1]  4  8 12 16 20 24 28 32 36 40
> 
+ + 
> foo <- function(){
+   cat("Hello SLU\n")
+ }
> foo()
Hello SLU
> foo
function(){
  cat("Hello SLU\n")
}
> 
+ + 
> foo1 <- function(x){
+   cat(paste("Hello", x, "\n"))
+ }
> foo1("Greyson")
Hello Greyson 
> foo1(4)
Hello 4 
> foo1(1:4)
Hello 1 
 Hello 2 
 Hello 3 
 Hello 4 
> foo1(c("Kjartan", "Sofia"))
Hello Kjartan 
 Hello Sofia 
> 
+ + 
> foo2 <- function(x = "Aadi"){
+   writeLines(paste0("Hello ", x, "!"))
+ }
> foo2(c("Kjartan", "Sofia"))
Hello Kjartan!
Hello Sofia!
> foo2()
Hello Aadi!
> 
+ . + 
> inch2cm <- function(x){
+   # stopifnot(is.numeric(x))
+   if(!is.numeric(x)) {
+     stop(paste(x, "is not numeric!"))
+   }
+   res <- x * 2.54
+   res
+ }
> inch2cm(1)
[1] 2.54
> inch2cm(1:10)
 [1]  2.54  5.08  7.62 10.16 12.70 15.24 17.78 20.32 22.86 25.40
> # inch2cm("a")
> data(trees)
> str(trees)
'data.frame':	31 obs. of  3 variables:
 $ Girth : num  8.3 8.6 8.8 10.5 10.7 10.8 11 11 11.1 11.2 ...
 $ Height: num  70 65 63 72 81 83 66 75 80 75 ...
 $ Volume: num  10.3 10.3 10.2 16.4 18.8 19.7 15.6 18.2 22.6 19.9 ...
> trees[, 1]
 [1]  8.3  8.6  8.8 10.5 10.7 10.8 11.0 11.0 11.1 11.2 11.3 11.4 11.4 11.7 12.0
[16] 12.9 12.9 13.3 13.7 13.8 14.0 14.2 14.5 16.0 16.3 17.3 17.5 17.9 18.0 18.0
[31] 20.6
> inch2cm(trees[, 1])
 [1] 21.082 21.844 22.352 26.670 27.178 27.432 27.940 27.940 28.194 28.448
[11] 28.702 28.956 28.956 29.718 30.480 32.766 32.766 33.782 34.798 35.052
[21] 35.560 36.068 36.830 40.640 41.402 43.942 44.450 45.466 45.720 45.720
[31] 52.324
> trees$Girth_cm <- inch2cm(trees[, 1])
> head(trees)
  Girth Height Volume Girth_cm
1   8.3     70   10.3   21.082
2   8.6     65   10.3   21.844
3   8.8     63   10.2   22.352
4  10.5     72   16.4   26.670
5  10.7     81   18.8   27.178
6  10.8     83   19.7   27.432
> 
+ . + 
> s1 <- function(x){
+   res <- 0
+   for(i in seq_along(x)){
+     res <- res + x[i]
+   }
+   res
+ }
> s1(3:4)
[1] 7
> sum(3:4)
[1] 7
> 
+ . + 
> s2 <- function(x){
+   res <- 0
+   i <- 1
+   while(i <= length(x)){
+     res <- res + x[i]
+     i <- i + 1
+   }
+   res
+ }
> s2(3:4)
[1] 7
> ### implicit loops
> lapply(l1, length)
[[1]]
[1] 10

[[2]]
[1] 10

[[3]]
[1] 10

> lapply(l1[2:3], mean)
[[1]]
[1] 7.9

[[2]]
[1] 4.981684

> unlist(lapply(l1[2:3], mean))
[1] 7.900000 4.981684
> sapply(l1[2:3], mean)
[1] 7.900000 4.981684
> lapply(l1[2:3], inch2cm)
[[1]]
 [1]  5.08 12.70  5.08 10.16 15.24 20.32 25.40 30.48 35.56 40.64

[[2]]
 [1]  5.080000 11.430000 17.780000 24.130000 30.480000 36.830000 -1.591193
 [8]  0.466454 -2.122497  4.052013

> ls()
 [1] "cv"      "df1"     "df1f"    "df2"     "dv"      "foo"     "foo1"   
 [8] "foo2"    "inch2cm" "iris"    "iriscsv" "iv"      "iv1"     "l1"     
[15] "l2"      "l3"      "quality" "s1"      "s2"      "t3"      "trees"  
> rm(list = ls())
> ls()
character(0)
> ### plotting
> X11()
> with(iris, plot(Petal.Length ~ Sepal.Length))
> with(iris, plot(Petal.Length ~ Sepal.Length, col = Species))
> library(ggplot2)
> ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + 
+   geom_point()
> ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + 
+   geom_point(aes(col = Species))
> ggplot(iris, aes(x = Sepal.Length, y = Petal.Length,
+                  col = Species)) + geom_point()
> ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + 
+   geom_point(aes(col = Species)) + geom_smooth()
`geom_smooth()` using method = 'loess'
> ## 1 model
> ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + 
+   geom_point(aes(col = Species)) + geom_smooth(method = "lm")
> ### 3 models
> ggplot(iris, aes(x = Sepal.Length, y = Petal.Length)) + 
+   geom_point(aes(col = Species)) +
+   geom_smooth(aes(col = Species))
`geom_smooth()` using method = 'loess'
> ## the same
> ggplot(iris, aes(x = Sepal.Length, y = Petal.Length,
+                  col = Species)) + 
+   geom_point() + geom_smooth()
`geom_smooth()` using method = 'loess'
> ggplot(iris, aes(x = Sepal.Length, y = Petal.Length, 
+                  col = Species)) + 
+   geom_point() + geom_smooth(method = "lm")
> ggplot(iris, aes(x = Sepal.Length, y = Petal.Length, 
+                  col = Species)) + 
+   geom_point() + geom_smooth(method = "gam")
> getwd()
[1] "/home/tux/Dokumente/lehre/ISPS17"
> ggsave("irisspecmodel.pdf")
Saving 6.99 x 7 in image
> ggsave("irisspecmodel.pdf", width = 15, height = 10,
+        units = "cm")
> ggsave("irisspecmodel.png", width = 15, height = 10,
+        units = "cm", dpi = 600)
pdf("irisplot_base.pdf")
> 
> with(iris, plot(Petal.Length ~ Sepal.Length, col = Species))
> dev.off()
X11cairo 
       2 
> q("no")

Process R finished at Thu Jun 15 14:06:08 2017
